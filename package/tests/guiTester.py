#from package.tests.ui.tableTestUI import Ui_MainWindow
import sip
sip.setapi('QVariant', 2) # This makes the spinbox deligate work without a type error
import package.tests.ui.tableTestUI # Import UI generated by QT Designer
from PyQt4 import QtGui, QtCore
import sys
import qdarkstyle
import fancyqt.firefox
import logging
from guppy import hpy
import random
import datetime
import models.SequenceClass
import models.DaqClass

h = hpy()
h.setref()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

darkUI = 1
fancyUI = 0

# This inserts double spinBoxes in a tableWidget
class SpinBoxDelegate(QtGui.QItemDelegate):
    def createEditor(self, parent, option, index):
        editor = QtGui.QDoubleSpinBox (parent)
        editor.setMinimum(0.00)
        editor.setMaximum(10000.00)
        editor.setDecimals(1)
        return editor

    def setEditorData(self, spinBox, index):
        try:
            value = index.model().data(index, QtCore.Qt.EditRole)
            spinBox.setValue(float(value))
            logger.debug( "setEditorData: value: " + str(float(value)))
            logger.debug( "setEditorData: spinBox: " + str(spinBox))
            logger.debug( "setEditorData: index: " + str(index))
        except:
            pass

    def setModelData(self, spinBox, model, index):
        spinBox.interpretText()
        value = spinBox.value()
        model.setData(index, value, QtCore.Qt.EditRole)

    def updateEditorGeometry(self, editor, option, index):
        editor.setGeometry(option.rect)


class TableTester(QtGui.QMainWindow, package.tests.ui.tableTestUI.Ui_MainWindow):
    def __init__(self):
        super(self.__class__, self).__init__()
        self.setupUi(self)
        logger.info("TableTester() __Init__")
        self.setWindowTitle('Table UI Widget Test Program')
        self.sequenceTableWidget.resizeColumnsToContents()
        self.daqTableWidget.resizeColumnsToContents()
        # Button event connectors
        self.heapyButton.clicked.connect(self.heapy_clicked)
        self.testDaqTableButton.clicked.connect(self.test_daq_table)
        self.clearDaqButton.clicked.connect(self.clear_daq)
        self.addStepButton.clicked.connect(self.add_sequence_step)
        self.removeStepButton.clicked.connect(self.remove_sequence_step)
        self.clearButton.clicked.connect(self.clear_sequence)
        # Menu bar event connectors
        self.actionSave_Daq.triggered.connect(self.save_daq_file)
        self.actionLoad_Daq.triggered.connect(self.load_daq_file)
        self.actionSave_Program.triggered.connect(self.save_sequence)
        self.actionLoad_Program.triggered.connect(self.load_sequence)
        # Table widget event connectors
        self.sequenceTableWidget.itemChanged.connect(self.sequence_table_update)
        # Table Widget Spin-Box Deligate
        self.delegate = SpinBoxDelegate()
        self.sequenceTableWidget.setItemDelegate(self.delegate)
        # Instantiation of model classes
        self.myDAQ = models.DaqClass.DaqClass(0)
        self.mySequence = models.SequenceClass.SequenceClass(sequence_length=0)
        self.sequenceTableWidget.setRowCount(0)
        self.add_sequence_step() # adds initial step to match UI

    def heapy_clicked(self):
        self.textEdit.clear()
        self.textEdit.append(str(h.heap()))

    def test_daq_table(self):
        self.myDAQ.reset_daq()
        # This creates simulated data to test the DAQ table widget
        timer_ms = 100
        elapsed_time = 0
        logger.info("test_daq_table(): Adding a few dummy Samples")
        for x in range(0, 8):
            myDatetime = datetime.datetime.now()  # Gets the current Datetime
            temp = random.randrange(0.0, 200.0, 1)
            self.myDAQ.add_sample(sample_temp=temp, sample_time_ms=elapsed_time, sample_datetime=myDatetime,
                             sample_setpoint=setPoint, sample_error=None)
            elapsed_time  += timer_ms
        self.myDAQ.get_qtable_from_array(self.myDAQ.dataset, self.daqTableWidget)

    def clear_daq(self):
        self.myDAQ.reset_daq(self.daqTableWidget)


    def save_daq_file(self):
        logger.info("save_daq_file()")
        self.statusbar.showMessage("Saving DAQ File...", 1500)
        self.myDAQ.save_daq_data()

    def load_daq_file(self):
        logger.info("load_daq_file()")
        self.statusbar.showMessage("Loading DAQ File...", 1500)
        self.myDAQ.load_daq_data()
        self.myDAQ.get_qtable_from_array(self.myDAQ.dataset, self.daqTableWidget)

######## Sequence CRUD Below ###########
    def add_sequence_step(self):
        rowcount = self.mySequence.length()
        logger.info("add_sequence_step(%s)" % rowcount)
        self.mySequence.add_step(0.0,0.0)
        rowcount = self.mySequence.length()
        logger.info( "new rowcount: " + str(rowcount))
        for row in xrange(0,rowcount-1):
            step_time = self.sequenceTableWidget.item(row,0)
            step_temperature = self.sequenceTableWidget.item(row,1)
            self.mySequence.stepTemperatures[row]= float(step_time.text())
            self.mySequence.stepTimesInSeconds[row] =  float(step_temperature.text())
        self.mySequence.get_sequence_qtable_from_array(self.mySequence.steps,self.sequenceTableWidget, rowcount)
        logger.info("add_sequence_step(): self.mySequence.steps: " + str(self.mySequence.steps))

    def remove_sequence_step(self):
        rowcount = self.mySequence.length()
        if rowcount > 1:
            rowcount = rowcount  - 1
            logger.info("remove_sequence_step(%s)" % str(rowcount))
            self.mySequence.remove_step(rowcount)
            self.mySequence.get_sequence_qtable_from_array(self.mySequence.steps,self.sequenceTableWidget, rowcount)
            logger.info("remove_sequence_step(): self.mySequence.steps: " + str(self.mySequence.steps))
        pass

    def clear_sequence(self):
        logger.info("clear_sequence()")
        self.mySequence.reset_sequence(self.sequenceTableWidget)
        self.add_sequence_step() # adds initial step to match UI

    def save_sequence(self):
        logger.info("save_sequence()")
        self.mySequence.save_sequence()

    def load_sequence(self):
        self.sequenceTableWidget.setRowCount(0)
        logger.info("load_sequence()")
        self.statusbar.showMessage("Loading Sequence File...", 1500)
        self.mySequence.load_sequence()
        rowcount = self.mySequence.length()
        self.mySequence.get_sequence_qtable_from_array(self.mySequence.steps,self.sequenceTableWidget, rowcount)
        logger.info("load_sequence(): self.mySequence.steps: " + str(self.mySequence.steps))

    # This is an event handler for any changes to the sequence tableWidget
    def sequence_table_update(self, item):
        row = item.row()
        col = item.column()
        logger.info("sequence_table_update(item): " + str(row) + "," + str(col))
        step_time = self.sequenceTableWidget.item(row,0)
        step_temperature = self.sequenceTableWidget.item(row,1)
        if step_time is not None:
            self.mySequence.stepTemperatures[row]= float(step_time.text())
        if step_temperature is not None:
            self.mySequence.stepTimesInSeconds[row] =  float(step_temperature.text())
        logger.info("sequence_table_update(): self.mySequence.steps: " + str(self.mySequence.steps))

# Main entry point
def run():
    app = QtGui.QApplication(sys.argv)
    # setup stylesheet
    if darkUI:
        app.setStyleSheet(qdarkstyle.load_stylesheet(pyside=False))
    elif fancyUI:
        app.setStyleSheet(fancyqt.firefox.style)
    form = TableTester()
    form.show()
    app.exec_()
    app.deleteLater()
    sys.exit(0)

if __name__ == '__main__':
    sys.exit(run())
